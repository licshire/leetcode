
### 最大子序列
最大子序列是要找出由数组成的一维数组中和最大的连续子序列。比如{5,-3,4,2}的最大子序列就是 {5,-3,4,2}，它的和是8,达到最大。

nums[]
maxSofar
tmpMax
for i in nums.length:
  tmpMax = max(tmpMax, tmpMax+nums[i]);
  maxSofar = max(maxSofar, tmpMax);

### 最长递增子序列
什么是最长上升子序列？ 就是给你一个序列，请你在其中求出一段不断严格上升的部分，它不一定要连续。
就像这样：2,3,4,7和2,3,4,6就是序列2 5 3 4 1 7 6的两种选取方案。最长的长度是4.

```
int a[MAX] //数据;
int lis(int x)
{
    int num[MAX];
    for(int i=0;i<x;i++)
    {
        num[i]=1;
        for(int j=0;j<i;j++)//更快可以二分，维护一个栈，如果比栈顶大直接压栈
        {
            if(a[j]<a[i]&&num[j]+1>num[i])
                   num[i]=num[j]+1;
        }
    }
    int maxx=0;
    for(int i=0;i<x;i++)
        if(maxx<num[i])
            maxx=num[i];
    return maxx;
}
```

### 最长公共子串
找两个字符串的最长公共子串，这个子串要求在原字符串中是连续的。
类似最长公共子序列的分析，这里，我们使用dp[i][j]表示 以x[i]和y[j]结尾的最长公共子串的长度，因为要求子串连续，所以对于X[i]与Y[j]来讲，它们要么与之前的公共子串构成新的公共子串；要么就是不构成公共子串。故状态转移方程

X[i] == Y[j]，dp[i][j] = dp[i-1][j-1] + 1
X[i] != Y[j]，dp[i][j] = 0
对于初始化，i==0或者j==0，如果X[i] == Y[j]，dp[i][j] = 1；否则dp[i][j] = 0。
```
void LCS_dp(char * X, int xlen, char * Y, int ylen)
{
    maxlen = maxindex = 0;
    for(int i = 0; i < xlen; ++i)
    {
        for(int j = 0; j < ylen; ++j)
        {
            if(X[i] == Y[j])
            {
                if(i && j)
                {
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                if(i == 0 || j == 0)
                {
                    dp[i][j] = 1;
                }
                if(dp[i][j] > maxlen)
                {
                    maxlen = dp[i][j];
                    maxindex = i + 1 - maxlen;
                }
            }
        }
    }
    outputLCS(X);
}
```


### 最长公共子序列（LCS）
给出多个（这里暂且只考虑两个）序列，求他们的最长公共子序列，就是在这两个序列中分别删去一些的字符，得到两个相同的序列，使得这两个相同的序列最长。


```
    l1=strlen(x);l2=strlen(y);
    for(i=1;i<=l1;i++)
        for(j=1;j<=l2;j++)
            if(x[i-1]==y[j-1])
                c[i][j]=c[i-1][j-1]+1;
            else
                // c[i][j] 不会比任意一个c[i-1][j],c[i][j-1]小，也不会比两者都大
                c[i][j]=max(c[i-1][j],c[i][j-1]);
```

